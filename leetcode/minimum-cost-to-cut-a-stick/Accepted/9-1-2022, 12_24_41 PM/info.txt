{"id":788723330,"lang":"python3","lang_name":"Python3","time":"2Â months","timestamp":1662027881,"status":10,"status_display":"Accepted","runtime":"665 ms","url":"/submissions/detail/788723330/","is_pending":"Not Pending","title":"Minimum Cost to Cut a Stick","memory":"14.1 MB","code":"# class Solution:\n#     def minCost(self, lenght: int, lst: List[int]) -> int:\n         \n#             n = len(lst)\n#             lst = sorted(lst)\n#             lst.insert(0, 0)\n#             lst.append(lenght)\n#             cache = {}\n#             @lru_cache(maxsize=8192)\n#             def dfs(l, r):\n#                 if (l, r) in cache:\n#                     return cache[(l, r)]\n#                 if r-l == 1:\n#                     return 0\n#                 ans = float('inf')\n#                 for i in range(len(lst)):\n#                     if i > l and i < r:\n#                         ans = min(ans, dfs(l, i)+dfs(i, r)+lst[r]-lst[l])\n#                 cache[(l, r)] = ans\n#                 return ans\n#             return dfs(0, n+1)\n# class Solution:\n#     def minCost(self, n: int, cuts: List[int]) -> int:\n#         cuts.extend([0,n])\n#         cuts.sort()\n#         l = len(cuts)\n#         dp = [[float('inf')]*l for _ in range(l)]\n#         for i in range(l):\n#             for j in range(2):\n#                 if i+j < l:\n#                     dp[i][i+j] = 0\n#         for k in range(2,l):\n#             for i in range(l-k):\n#                 for j in range(i+1,i+k):\n#                     dp[i][i+k] = min(dp[i][i+k],cuts[i+k]-cuts[i]+dp[i][j]+dp[j][i+k])\n#         return dp[0][l-1]\n# class Solution: # Python\n    # def minCost(self, n: int, cuts: List[int]) -> int:\n    #     @functools.lru_cache(None)\n    #     def fn(lo, hi):\n    #         cc = [c for c in cuts if lo < c < hi]  # collect cuts within this region\n    #         if not cc:\n    #             return 0\n    #         ans = float('inf')\n    #         for mid in cc: # choose a cut in that is in the region to be mid\n    #             ans = min(ans, fn(lo, mid) + fn(mid, hi))\n    #         return ans + hi - lo # ans + currentCut\n    #     return fn(0, n)\n     # def minCost(self, N: int, cuts: List[int]) -> int:\n     #    c=len(cuts)\n     #    cuts.append(0)\n     #    cuts.append(N)\n     #    cuts.sort()\n     #    dp=[[0 for i in range(c+2)]for j in range(c+2)]  \n     #    for i in range(c,0,-1):\n     #        for j in range(1,c+1):\n     #            if i>j:\n     #                continue\n     #            mini=float(\"inf\")\n     #            for ind in range(i,j+1):\n     #                cost=cuts[j+1]-cuts[i-1] +dp[i][ind-1] + dp[ind+1][j]\n     #                mini=min(mini,cost)\n     #            dp[i][j]=mini\n     #    return dp[1][c]\nclass Solution:\n    def minCost(self, n: int, cuts: List[int]) -> int:\n        cuts.sort()\n        cuts = [0] + cuts + [n]\n        dp = [[0] * len(cuts) for _ in range(len(cuts))]\n        for i in range(len(cuts) - 1, -1, -1):\n            for j in range(i + 1, len(cuts)):\n                if j - i == 1:\n                    dp[i][j] = 0\n                else:\n                    dp[i][j] = min(dp[i][k] + dp[k][j] for k in range(i + 1, j)) + cuts[j] - cuts[i]\n        return dp[0][-1]\n","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"minimum-cost-to-cut-a-stick","has_notes":false,"notes":"","topic_tags":[]}