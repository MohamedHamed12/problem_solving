{"id":833783597,"lang":"python3","lang_name":"Python3","time":"5 days, 13 hours","timestamp":1667192420,"status":10,"status_display":"Accepted","runtime":"2801 ms","url":"/submissions/detail/833783597/","is_pending":"Not Pending","title":"Height of Binary Tree After Subtree Removal Queries","memory":"160.8 MB","code":"# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def treeQueries(self, r: Optional[TreeNode], queries: List[int]) -> List[int]:\n        height,depth=defaultdict(list),defaultdict(list)\n        def dfs(root ,h):\n            if not root:return -1\n            height[root.val]=h\n            mx=max(dfs(root.left,h+1),dfs(root.right,h+1))+1\n            depth[root.val]=mx\n            return mx\n        dfs(r,0)\n        cousin=defaultdict(list)\n        for val ,h in height.items():\n            cousin[h].append((depth[val],val))\n            cousin[h].sort()\n            if len(cousin[h])>2:cousin[h].pop(0)\n        ans =deque()\n        for q in queries:\n            h=height[q]\n            # ans.append(cousin[h])\n            if len(cousin[h])==1:ans.append(h-1)\n            elif cousin[h][1][1]==q:ans.append(h+cousin[h][0][0])\n            else :ans.append(h+cousin[h][1][0])\n        return ans\n","compare_result":"111111111111111111111111111111111111111","title_slug":"height-of-binary-tree-after-subtree-removal-queries","has_notes":false,"notes":"","topic_tags":[]}