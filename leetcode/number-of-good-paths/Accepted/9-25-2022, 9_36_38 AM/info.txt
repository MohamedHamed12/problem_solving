{"id":808124830,"lang":"python3","lang_name":"Python3","time":"1 month, 1 week","timestamp":1664091398,"status":10,"status_display":"Accepted","runtime":"4598 ms","url":"/submissions/detail/808124830/","is_pending":"Not Pending","title":"Number of Good Paths","memory":"33.3 MB","code":"class Solution:\n    def numberOfGoodPaths(self, vals: List[int], edges: List[List[int]]) -> int:\n        n = len(vals)\n\n        val2node = defaultdict(list)\n        for i in range(n):\n            val2node[vals[i]].append(i)\n        \n        val2edge = defaultdict(list)\n        for i, j in edges:\n            val2edge[max(vals[i], vals[j])].append((i, j))\n        \n        parent = list(range(n))\n        def find(k):\n            if parent[k] != k:\n                parent[k] = find(parent[k])\n            return parent[k]\n        \n        def connect(k1, k2):\n            parent[find(k2)] = find(k1)\n\n        res = 0\n        for val in sorted(val2node.keys()):\n            for i, j in val2edge[val]:\n                connect(i, j)\n            count = defaultdict(int)\n            for node in val2node[val]:\n                count[find(node)] += 1\n            for group in count:\n                res += (count[group] * (count[group] + 1))//2\n        return res","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"number-of-good-paths","has_notes":false,"notes":"","topic_tags":[]}