{"id":772131486,"lang":"python3","lang_name":"Python3","time":"2 months, 3 weeks","timestamp":1660332954,"status":10,"status_display":"Accepted","runtime":"7011 ms","url":"/submissions/detail/772131486/","is_pending":"Not Pending","title":"Burst Balloons","memory":"30.8 MB","code":"class Solution:\n    def maxCoins(self, nums: List[int]) -> int:\n        nn=len(nums)\n        nums=[1]+nums+[1]\n        # cache={}\n        @cache\n        def dfs(l,r):\n            if l>=r:return 0\n            tmp=0\n            for cur in range(l+1,r):\n                prod=nums[cur]*nums[l]*nums[r]\n                tmp=max(tmp,prod+dfs(l,cur)+dfs(cur,r))\n                \n            return tmp\n        return dfs(0,len(nums) - 1)\n\n\n#         orig_size = len(nums)\n#         nums = [1] + nums + [1]\n        \n#         @cache\n#         def dfs(left, right):\n#             if left >= right:\n#                 return 0\n            \n#             ret = 0\n            \n#             for last in range(left + 1, right):\n#                 # remainder: we want to burst all the way to the left/right\n#                 prod = nums[left] * nums[last] * nums[right]\n#                 # note, here k is always skipped in the recursive calls below \n#                 ret = max(ret, prod + dfs(left, last) + dfs(last, right))\n            \n#             return ret\n         \n#         # we never want to pop the virtual 1s so we start at i + 1 in the loop\n#         return dfs(0, len(nums) - 1)","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"burst-balloons","has_notes":false,"notes":"","topic_tags":[]}